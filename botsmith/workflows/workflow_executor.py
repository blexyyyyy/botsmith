import json
from pathlib import Path
from typing import Dict, Any, List




class WorkflowExecutor:
    """
    Executes workflow steps generated by WorkflowFactory.
    Handles:
    - Step dispatch
    - Context merging
    - Retry logic
    - Failure policies
    - Special expansion step: generate_all_files
    - Final code writing to botsmith/generated/<project_name>
    """

    GENERATED_ROOT = Path("generated")

    def __init__(self, agent_factory, workflow_repo=None):
        self.agent_factory = agent_factory
        self.workflow_repo = workflow_repo  # optional

    # ----------------------------------------------------------------------
    # ENTRY POINT
    # ----------------------------------------------------------------------
    def execute(self, workflow_def: Dict[str, Any], initial_context: Dict[str, Any], on_event=None) -> Dict[str, Any]:
        """
        Executes the workflow.
        :param on_event: Optional callback(event_type, event_data) for real-time updates.
        """
        context = dict(initial_context)
        log = []

        steps = workflow_def["steps"]

        for step_def in steps:
            step_name = step_def["step"]
            agent_name = step_def["agent"]
            retry_limit = step_def.get("retry", 1)
            failure_policy = step_def.get("on_failure", "abort")

            # Emit step start event
            if on_event:
                on_event("step_start", {"step": step_name, "agent": agent_name})

            # Special-case expansion
            if step_name == "generate_all_files":
                # Pass on_event to file generator for granular updates
                result = self._run_generate_all_files(context, step_def, on_event)
                log.append(self._log_entry(step_name, agent_name, "success", 1, result))
                context.update(result)
                
                if on_event:
                    on_event("step_complete", {"step": step_name, "status": "success"})
                continue
            
            # Normal step execution
            attempt = 0
            success = False
            last_error = None

            while attempt < retry_limit and not success:
                attempt += 1
                try:
                    result = self._run_step(agent_name, step_name, context)
                    success = True
                    context.update(result)
                    log.append(self._log_entry(step_name, agent_name, "success", attempt, result))
                    
                    if on_event:
                         # Try to extract log/summary from result
                         summary = result.get("summary") or f"Completed {step_name}"
                         on_event("log", {"message": summary})

                except Exception as e:
                    last_error = str(e)
                    log.append(self._log_entry(step_name, agent_name, "failed", attempt, error=last_error))
                    if on_event:
                        on_event("log", {"message": f"Error in {step_name}: {last_error}", "level": "error"})

            if success:
                if on_event:
                    on_event("step_complete", {"step": step_name, "status": "success"})
            else:
                if on_event:
                    on_event("step_complete", {"step": step_name, "status": "failed", "error": last_error})
                    
                if failure_policy == "abort":
                    return {
                        "status": "failed",
                        "failed_step": step_name,
                        "error": last_error,
                        "log": log,
                        "context": context,
                    }
                elif failure_policy == "continue":
                    continue
                else:
                    raise ValueError(f"Unknown failure policy: {failure_policy}")

        return {
            "status": "success",
            "log": log,
            "context": context,
        }

    # ----------------------------------------------------------------------
    # STEP EXECUTION
    # ----------------------------------------------------------------------
    def _run_step(self, agent_type: str, task: str, context: Dict[str, Any]) -> Dict[str, Any]:
        from botsmith.agents.registry import AgentRegistry
        agent_cls = AgentRegistry.get(agent_type)
        agent = self.agent_factory.create_agent({
            "type": agent_type, 
            "params": {
                "agent_id": f"{agent_type}_{task}",
                "agent_type": "logic"
            }
        })
        return agent.execute(task, context)

    # ----------------------------------------------------------------------
    # SPECIAL CASE: GENERATE ALL FILES
    # ----------------------------------------------------------------------
    def _run_generate_all_files(self, context: Dict[str, Any], step_def: Dict[str, Any], on_event=None) -> Dict[str, Any]:
        """
        file_plan_agent must have produced:
        context["files"] = [
            {"filename": "...", "description": "..."},
            ...
        ]
        """

        project_name = context["project_name"].lower().replace(" ", "_")
        
        fs = context.get("filesystem")
        if fs:
            output_dir = None # We will use fs relative paths
        else:
            output_dir = self.GENERATED_ROOT / project_name
            output_dir.mkdir(parents=True, exist_ok=True)

        generated_files = []
        errors = []

        for file_info in context.get("files", []):
            filename = file_info["filename"]
            description = file_info["description"]
            
            print(f"    [Executor] Generating file: {filename}...")
            if on_event:
                on_event("file_start", {"filename": filename, "description": description})

            # Determine agent based on extension
            is_doc = any(filename.endswith(ext) for ext in [".md", ".txt", ".rst"])
            agent_type = "doc_writer" if is_doc else "coder"
            agent_role = "doc" if is_doc else "code"
            
            # Generate
            agent = self.agent_factory.create_agent({
                "type": agent_type, 
                "params": {
                    "agent_id": f"{agent_type}_{filename}",
                    "agent_type": agent_role
                }
            })
            
            # Create a clean context for the single file generation
            # Remove 'files' to prevent CodeGeneratorAgent from entering batch mode
            coder_context = context.copy()
            # Pass file list as project_structure so the coder sees it
            coder_context["project_structure"] = [f["filename"] for f in context.get("files", [])]
            
            if "files" in coder_context:
                del coder_context["files"]
            
            result = agent.execute("generate_content", {
                **coder_context,
                "filename": filename,
                "description": description
            })

            if not result.get("validated"):
                errors.append({
                    "filename": filename,
                    "error": result.get("error"),
                })
                continue

            # Write code to disk
            if fs:
                # FilePlanAgent produces paths like "src/project/main.py"
                # We need to ensure we write to "{project_name}/{filename}"
                # But wait! FilePlanAgent output ALREADY contains "src/{project_name}/..."
                # Only if the filename doesn't start with project_name do we need to care?
                # Actually, ProjectScaffoldAgent creates "project_name" dir.
                # If filename is "src/bot/main.py", we want "bot/src/bot/main.py" ??
                # Let's look at ProjectScaffoldAgent again.
                # It creates "project_name" directory.
                # Then "src" inside it.
                # So "project_name/src/project_name/main.py".
                # If filename is "src/project_name/main.py", we need "project_name/src/project_name/main.py".
                full_rel_path = f"{project_name}/{filename}"
                fs.write_file(full_rel_path, result["code"])
                file_path = full_rel_path # for logging
            else:
                file_path = output_dir / filename
                file_path.parent.mkdir(parents=True, exist_ok=True)
                file_path.write_text(result["code"], encoding="utf-8")

            generated_files.append({
                "filename": filename,
                "path": str(file_path),
                "size": len(result["code"]),
            })
            
            if on_event:
                on_event("file_complete", {"filename": filename, "path": str(file_path)})

        return {
            "generated_files": generated_files,
            "file_errors": errors,
        }

    # ----------------------------------------------------------------------
    # LOGGING STRUCTURE
    # ----------------------------------------------------------------------
    def _log_entry(self, step, agent, status, attempt, result=None, error=None):
        return {
            "step": step,
            "agent": agent,
            "status": status,
            "attempt": attempt,
            "result": result,
            "error": error,
        }
